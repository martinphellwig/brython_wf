<html>
<head>
<meta charset="iso-8859-1">
<title>Brython</title>
<link rel="stylesheet" href="../doc_brython.css">
</head>
<body>
<a name="modele"><h3>Compiling and running</h3>


<h4>Overview</h4>
<table border=1 cellpadding =5>
<tr><td>Step </td><td>performed by</td></tr>
<tr>
    <td>Reading Python source</td>
    <td>function <code>brython(<i>debug_mode</i>)</code> in <b>py2js.js</b>
        <p>If the code is in an external file, it is retrieved by an Ajax call
        <p>This function creates the following environment variables :
        <ul>
         <li><code>document.$py_src</code> : object indexed by module names, value is the module source code
         <li><code>document.$debug</code> : debug level
         <li><code>document.$exc_stack</code> : a list of errors generated during parsing or at runtime
        </ul>
        
    </td>

</tr>

<tr>
    
    <td>creation of the tree reprenting the Python code</td>
    <td>function <code>$py2js(<i>source,module</i>)</code> in <b>py2js.js</b>
        <p>This function calls :
        <ul>
         <li><code>$tokenize(<i>source</i>)</code> : syntax analysis of the tokens in Pytho source code and tree building ;
             returns the tree root
         <li><code>transform(<i>root</i>)</code> : transforms the tree to prepare the conversion to Javascript (see below)
         <li><code>$add_line_num()</code> to add line numbers if debug mode is greater than 0
        </ul>
        <p>The function <code>$py2js</code> returns the tree root
    </td>
</tr>

<tr>
    
    <td>generating Javascript code</td>
    <td>method <code>to_js()</code> of the tree returned by <code>$py2js</code>
        <p>This function recursively calls the method of the same name on all the syntax elements found in the tree. It returns the string holding the resulting Javascript code. If debug mode is 2, this string is printed in the browser console
    </td>
</tr>

<tr>
    
    <td>running Javascript code</td>
    <td>evaluation by the function <code>eval()</code>
    
    </td>
</tr>

</table>

<p>
<h4>Files used</h4>

The script <b>brython.js</b> is generated by compilation of several scripts :
<ul>
<li><b>brython_builtins.js.js</b> : defines the object <code>__BRYTHON__</code> which acts as a gateway between Javascript native objects (<code>Date, RegExp, Storage...</code>) et Brython
<li><b>py2js.js</b> : performs the conversion from Python code to Javascript code
<li><b>py_utils.js</b> : utility functions (eg type conversions between Javascript and Python)
<li><b>py_string.js</b> : implémentation of Python <code>str</code> class, based on the Javascript type <code>String</code>
<li><b>py_list.js</b> : implémentation of Python <code>list</code> class, based on the Javascript type <code>Array</code>
<li><b>py_classes.js</b> : groups all the other built-in Python types and functions
<li><b>py_import.js</b> : implementation of <tt>import</tt>
<li><b>py_dom.js</b> : interaction with the HTML document (DOM)
<li><b>py_ajax.js</b> : Ajax implementation
</ul>


<p>
<h4>More on translation and running</h4>

Translation and run of a Brython script by <b>py2js.js</b> goes through the following steps :
<ol>
<li>syntax analysis and tree building
<p>This step relies on an automat whose state evolves with the tokens found in the source code
<p>Python code is split into tokens that can have the following types : 
<ul>
<li>keyword
<li>identifier
<li>literal (string, integer, float)
<li>operator
<li>period (.)
<li>colon (:)
<li>semi colon (;)
<li>parenthesis / bracket / curly brace
<li>assignment (equal sign =)
<li>decorator (@)
<li>end of line
</ul>

<p>For each token, a call to function <tt>$transition()</tt> is performs, it returns a new state depending on the current state and the token
<p>Each instruction in the source code matches a node in the tree (instance of class <tt>$Node</tt>). If a line holds more than one instruction separated by  ":" (<code>def foo(x):return x</code>) or by ; (<code>x=1;print(x)</code>), as many nodes are created for this line
<p>For each syntax element (identifier, function call, expression, operator...) there is a class describing this element syntax (see in the source code of  <b>py2js.js</b> between <code>function $AbstractExprCtx</code> and <code>function $UnaryCtx</code>)
<p>In this step, errors can be reported : 
<ul>
<li>syntax errors
<li>indentation errors
<li>unterminated sting literals
<li>unbalanced parenthesis / brackets / curly braces
<li>illegal character
<li>Python keyword not handled by Brython
</ul>
<p>
<li>Transforming the tree
<p>For some elements of the Python synatx, the tree representing the source code has to be modified (add branches) before starting the translation into Javascript. This is done by recursive calls to the method <code>transform</code> from the top of the tree, and by applying the method of the same name to the contexts of each node
<p>For isntance, for the Python code <code>assert <i>condition</i></code> that yields a single branch of the tree, this step transforms it into a branch <code>if not <i>condition</i></code> and a branch "child" with <code>raise AssertionError</code>
<p>The elements that must be transformed this way are : <code>assert</code>, chained (<code>x=y=0</code>) and multiple (<code>x,y=1,2</code>) assignments, <code>class, def, except, for, try</code>
<p>This step is also used to store the variables declared by <code>global</code>

<p>
<li>Running Javascript code
<p>At runtime the generated script can use :
<ul>
<li>the built-in classes defined in <tt>py_classes.js, py_string.js, py_list.js, py_dom.js, py_ajax.js</tt>
<li>internal functions, not accessible from Python (their name always starts with $) ; most of them are defined in <tt>$py_utils.js</tt>. The most important are :
<ul>
<li><tt>$JS2Py</tt> : takes a single argument and returns :
<ul>
<li>the argument unchanged if it is a type handled by Brython (id if it has an attribute <tt>__class__</tt>)
<li>an instance of DOMObject (respectively DOMEvent) if the argument is a DOM object (resp. event)
<li>an instance of JSObject "wrapping" the argument in the other cases
</ul>
<li><tt>$MakeArgs</tt> called at the beginning of each function if its signature has at least one argument. It builds a namespace based on the function arguments, calling the function <code>$JS2Py</code> on all arguments
<li><tt>$class_constructor</tt> is called for class definition
<li><tt>$resolve_attr</tt> is called to resolve class instances attributes and handles multiple inheritance
<li><tt>$list_comp</tt> is called for list comprehensions
<li><tt>$lambda</tt> is called for anonymous functions defined by <code>lambda</code>
<li><tt>$test_expr</tt> and <tt>$test_item</tt> are used in evaluation of conditions combined by <code>and</code> or <code>or</code>
</ul>
<li>the functions defined in the script <tt>py_import.js</tt> for management of imports
</ul>

</ol>
</body>
</html>