<html>
<head>
<title>Brython</title>
<link rel="stylesheet" href="../doc_brython.css">
<meta charset="iso-8859-1">
</head>
<body>
<a name="conv"><h3>Traducci&oacute;n de la sintaxis Python a c&oacute;digo Javascript</h3>

<p>
<table border=1>
<tr>
<th>Python</th>
<th>Javascript</th>
<th>Comentarios</th>
</tr>

<tr>
<td><pre>x = 1
y = 3.14
z = "azerty"</td>
<td><pre>x = int(1)
y = float(3.14)
z = "azerty"</pre>
</td>
<td><tt>float</tt> es una funci&oacute;n Javascript definida en <b>py_classes.js</b></td>
</tr>

<tr>
<td><pre>x = foo.bar</td>
<td><pre>x = foo.__getattr__('bar')</pre>
<td>&nbsp;</td>
</td>
</tr>

<tr>
<td><pre>foo.bar = x</td>
<td><pre>foo.__setattr__('bar',x)</pre>
<td>&nbsp;</td>
</td>
</tr>

<tr>
<td><pre>x = foo[bar]</td>
<td><pre>x = foo.__getitem__(bar)</pre>
<td>&nbsp;</td>
</td>
</tr>

<tr>
<td><pre>foo[bar] = x</td>
<td><pre>foo.__setitem__(bar,x)</pre>
<td>&nbsp;</td>
</td>
</tr>

<tr>
<td><pre>x+y</td>
<td><pre>x.__add__(b)</pre>
<td>Lo mismo para todos los operadores
<br>necesario implementar tales operaciones como 2 * "a"</td>
</td>
</tr>

<tr>
<td><pre>a and b</td>
<td><pre>$test_expr($test_item(a)&&$test_item(b))</pre>
<td>estamos manteniendo el operador && Javascript y de esa forma no se eval&uacute;a b is a es falso
<br><tt>$test_item</tt> devuelve un booleano Javascript (true o false) y almacena el resultado en una variable global; <tt>$test_expr</tt> devuelve esa variable global</td>
</td>
</tr>

<tr>
<td><pre>for obj in iterable:
    (...)</pre></td>
<td><pre>var $Iter1 = iterable
for (var $i1=0;$i1<$iter1.__len__();$i1++){ 
   obj =$iter1.__item__($i1)
   void(0)
}</pre>
</td>
<td>&nbsp;</td></tr>

<tr>
<td><pre>x,y = iterable</pre></td>
<td><pre>var $var =iterable 
x =$var.__item__(0) 
y =$var.__item__(1) 
</pre>
</td>
<td>&nbsp;</td></tr>

<tr>
<td><pre>x,y = a,b</pre></td>
<td><pre>var $temp=[]
$temp.push(a)
$temp.push(b)
x =$temp[0] 
y =$temp[1]
</pre>
</td>
<td>&nbsp;</td></tr>

<tr>
<td><pre>def foo():
   x=3
</pre></td>
<td><pre>function foo(){
   var x=3
}
window.foo=foo 
</td>
<td>Para ser consistente en la gesti&oacute;n del espacio de nombres (namespace) de Python, la variable local <tt>x</tt> ser&aacute; declarada por la keyword <em>var</em>
<p>La &uacute;ltima l&iacute;nea a&ntilde;ade el nombre de la funci&oacute;n al espacio de nombres del navegador; solo existir&aacute; si la funci&oacute;n est&aacute; en el nivel del m&oacute;dulo y no dentro de otra funci&oacute;n</td></tr>

<tr>
<td><pre>def foo():
   global x
   x=3
</pre></td>
<td><pre>function foo(){
   x=3
}
window.foo=foo 
</td>
<td>para una variable global no usamos la keyword <em>var</em></td>
</tr>

<tr>
<td><pre>def foo(x,y=3,*args,**kw):
   (...)
</pre></td>
<td><pre>function foo(){
   $ns=$MakeArgs(arguments,['x'],{"y":3},"args","kw")
   for($var in $ns){eval("var "+$var+"=$ns[$var]")} 
   (...)
}
window.foo=foo 
</td>
<td>la funci&oacute;n <tt>$MakeArgs</tt> crea un objeto Javascript combinando los nombres definidos en la firma de la funci&oacute;n con valores que han sido introducidos realmente. La siguiente l&iacute;nea crea el namespace de la funci&oacute;n (variables locales)</td>
</tr>

<tr>
<td><pre>foo(x,y=1)
</pre></td>
<td><pre>foo(x,$Kw("y",1))
</td>
<td>los argumentos introducidos como keywords se convierten en objetos creados por la funci&oacute;n <em>$Kw</em>
</tr>

<tr>
<td><pre>x='brython'
try:
    x[2]='a'
except TypeError:
    log('error')
except:
    log('another error')
</pre></td>
<td><pre>x ='brython' 
try{
    x.__setitem__(2,str('a'))
}
catch($err0){
    if(false){void(0)} 
    else if($err0.name=="TypeError"){
        log('error')
    }
    else{
        log('another error')
    }
}
</pre>
</td>
<td>las l&iacute;neas
<pre><b>catch($err0){
    if(false){void(0)} </b></pre><p>
se a&ntilde;aden antes que las cl&aacute;usulas <code>except</code>, traducido como <em>else if</em> cuando el nombre de una excepci&oacute;n se especifica o como un <em>else</em> cuando no es el caso

</tr>

</table>

<p>
<table border=1>
<tr>
<th>Javascript</th>
<th>Python</th>
<th>Comentario</th>
</tr>


<tr>
<td><pre>document</td>
<td><pre>doc</pre>
<td>&nbsp;</td>
</td>
</tr>

<tr>
<td><pre>document.getElementById(elt_id)</td>
<td><pre>doc[elt_id]</pre>
<td>&nbsp;</td>
</td>
</tr>

<tr>
<td><pre>document.getElementsByTagName('A')</td>
<td><pre>doc[A]</pre>
<td>devuelve una lista Python</td>
</td>
</tr>

<tr>
<td><pre>setInterval(func,millisec)</td>
<td><pre>import time
time.set_interval(func,millisec)</pre>
<td>&nbsp;</td>
</td>
</tr>

<tr>
<td><pre>clearInterval(interval_id)</td>
<td><pre>import time
time.clear_interval(interval_id)</pre>
<td>&nbsp;</td>
</td>
</tr>

<tr>
<td><pre>setTimeOut(func,millisec)</td>
<td><pre>import time
time.set_timeout(func,millisec)</pre>
<td>&nbsp;</td>
</td>
</tr>



</table>
<hr>
<a name="import"><h3>import</h3>
El import se realiza mediante llamadas Ajax

<p>Existen dos tipos de m&oacute;dulos importables:
<ul>
<li>m&oacute;dulos escritos en Javascript : <tt>time, datetime, math, random, sys</tt> (en los cuales solo algunos de los atributos y m&eacute;todos se encuentran implementados)
<li>m&oacute;dulos escritos en Python, los cuales ser&aacute;n importados desde la misma carpeta desde la que se encuentra el script que realiza la llamada
</ul>

</body>
</html>
