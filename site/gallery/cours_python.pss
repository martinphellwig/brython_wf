@title Introduction à Python
@pagenum True

Introduction à Python
=====================


../..
Historique
==========
- créé en 1989 par Guido van Rossum
- version 2.0 en 2000
- version 3.0 en 2008 (quelques incompatibilités)
../..
Caractéristiques
================
- pratique plus que puriste
- accent sur la lisibilité
- typage fort, mais non déclaré
- coeur minimaliste, mais bibliothèque très étendue
../..
Popularité
==========
<img src='tiobe.png' height=400>
../..
Popularité
==========
<img src='Languages_2013-12.png' height=400>
../..
Popularité
==========
Projets créés sur Github en 2013

<pre>
Rank    Language      # Repositories Created
1    JavaScript    264131
2    Ruby          218812
3    Java          157618
4    PHP           114384
5    Python         95002
6    C++            78327
7    C              67706
8    Objective-C    36344
9    C#             32170
10    Shell          28561
</pre>
../..
Installation
============
Aller sur le [site](http://python.org) et suivre les instructions
../..
Ressources
==========
- la documentation Python : site, doc Windows
- forums : [comp.lang.python](https://groups.google.com/forum/?fromgroups#!forum/comp.lang.python), [comp.lang.python.fr](https://groups.google.com/forum/?fromgroups#!forum/fr.comp.lang.python)
- [stackoverflow](http://stackoverflow.com/)
../..
Commentaires
============
Introduits par #

    # this is the first comment
    SPAM = 1                 # and this is the second comment
                             # ... and now a third!
    STRING = "# This is not a comment."
../..
Définition de noms
==================

    >>> width = 20
    >>> height = 5*9
    
    >>> x = y = z = 0
    
    >>> tax = 0.125
    >>> ht = 100.50
    >>> ttc = ht * (1+tax)
    >>> round(ttc, 2)
    113,06
../..
Chaines de caractères
=====================
Utilise ' ou "
    'spam eggs'
    'doesn\'t'
    "doesn't"
    '"Yes," he said.'
    "\"Yes,\" he said."
    '"Isn\'t," she said.'
../..
Chaines de caractères
=====================
\ pour continuer une ligne
    hello = "This is a rather long string containing\n\
    several lines of text just as you would do in C.\n\
        Note that whitespace at the beginning of the line is\
     significant."

""" sur plusieurs lignes
    print """
    Usage: thingy [OPTIONS]
         -h                        Display this usage message
         -H hostname               Hostname to connect to
    """
../..
Chaines de caractères
=====================
Mode par défaut :
    >>> word = 'a\nb'
    >>> print(word)
    a
    b
    
Mode brut :
    >>> word = r'a\nb'
    >>> print(word)
    a\nb
    
../..
Chaines de caractères
=====================
Concaténation par +, duplication par *

    >>> word = 'Help' + 'A'
    >>> word
    'HelpA'
    >>> '<' + word*5 + '>'
    '<HelpAHelpAHelpAHelpAHelpA>'
../..
Chaines de caractères
=====================
Accès à un caractère par index
------------------------------
     +---+---+---+---+---+
     | H | e | l | p | A |
     +---+---+---+---+---+
       0   1   2   3   4
      -5  -4  -3  -2  -1
            
    >>> word[4]
    'A'
    >>> word[-2]
    'p'
../..
Chaines de caractères
=====================
Tranches
--------
     +---+---+---+---+---+
     | H | e | l | p | A |
     +---+---+---+---+---+
     0   1   2   3   4   5
    -5  -4  -3  -2  -1
    >>> word[0:2]
    'He'
    >>> word[2:4]
    'lp'
    >>> word[:2]
    'He'
    >>> word[3:]
    'pA'
../..
Chaines de caractères
=====================
Les chaines sont immuables
--------------------------

    >>> word = 'HelpA'
    >>> word[1]='a'
    TypeError: 'str' object does not support item assignment
Longueur d'une chaine
---------------------

    >>> word = 'anticonstitutionnellement'
    >>> len(word)
    25
../..
Listes
======
    >>> a = ['spam', 'eggs', 100, 1234]
    >>> a
    ['spam', 'eggs', 100, 1234]

Accès par index ou par tranche

    >>> a[0]
    'spam'
    >>> a[3]
    1234
    >>> a[-2]
    100
    >>> a[1:-1]
    ['eggs', 100]
../..
Listes
======
Concaténation par +, duplication par *

    >>> 3*a[:3] + ['Boo!']
    ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']        

Clonage

    >>> a[:]
../..
Listes
======
Les listes sont mutables

    >>> a
    ['spam', 'eggs', 100, 1234]
    >>> a[2] = a[2] + 23
    >>> a
    ['spam', 'eggs', 123, 1234]
../..
Listes
======
Longueur d'une chaine par `len`

    >>> a = ['a', 'b', 'c', 'd']
    >>> len(a)
    4
../..
Listes
======
Une liste peut contenir d'autres listes
    >>> q = [2, 3]
    >>> p = [1, q, 4]
    >>> len(p)
    3
    >>> p[1]
    [2, 3]
    >>> p[1][0]
    2
../..
Listes
======
Ajout d'un élément à la fin d'une liste par `append`
    >>> p[1].append('xtra')
    >>> p
    [1, [2, 3, 'xtra'], 4]
    >>> q
    [2, 3, 'xtra']
Insertion d'un élément à une position donnée par `insert`
    >>> q.insert(1,'new')
    >>> q
    [2, 'new', 3, 'xtra']
    >>>
../..
Tuples
======
Comme une liste, mais immuable

    >>> t = (1,2,'a')
    >>> t[1]
    2
    >>> t[2] = 'b'
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'tuple' object does not support item assignment

../..
Premiers pas en programmation
=============================
Suite de Fibonacci

    >>> a, b = 0, 1
    >>> while b < 10:
    ...     print(b)
    ...     a, b = b, a+b
    ...
    1
    1
    2
    3
    5
    8
A noter :
- assignement multiple : `a, b = 0, 1`
- indentation
 - utiliser de préférence 4 espaces
- boucle `while`
../..
La fonction `print`
===================
    >>> i = 256*256
    >>> print('La valeur de i est', i)
    La valeur de i est 65536

Le mot-clé *end*

    >>> a, b = 0, 1
    >>> while b < 1000:
    ...     print(b, end=',')
    ...     a, b = b, a+b
    ...
    1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
../..
Conditions : `if, elif, else`
=============================
    >>> x = int(input("Please enter an integer: "))
    Please enter an integer: 42
    >>> if x < 0:
    ...      x = 0
    ...      print('Negative changed to zero')
    ... elif x == 0:
    ...      print('Zero')
    ... elif x == 1:
    ...      print('Single')
    ... else:
    ...      print('More')
    ...
    More

nb : pas de "switch / case"
../..
Boucle `for`
============
Un des outils les plus puissants de Python
    >>> a = ['cat', 'window', 'defenestrate']
    >>> for x in a:
    ...     print(x, len(x))
    ...
    cat 3
    window 6
    defenestrate 12

../..
La fonction `range`
===================
    >>> for i in range(5):
    ...     print(i)
    ...
    0
    1
    2
    3
    4

syntaxe : `range(start,stop,step)`
../..
Itérateurs
==========
    >>> print(range(10))
    range(0, 10)

`range` ne renvoie pas une liste de valeurs, mais un _itérateur_

Dans `for x in A`, *A* est un itérateur

Certaines fonctions prennent un itérateur comme argument, par exemple `list`

    >>> list(range(5))
    [0, 1, 2, 3, 4]

../..
`continue`
==========
    >>> for num in range(2, 10):
    ...     if num % 2 == 0:
    ...         print("Found an even number", num)
    ...         continue
    ...     print("Found a number", num)
    Found an even number 2
    Found a number 3
    Found an even number 4
    Found a number 5
    Found an even number 6
    Found a number 7
    Found an even number 8
    Found a number 9
../..
`break` et `else` dans une boucle
=================================
    >>> for n in range(2, 10):
    ...     for x in range(2, n):
    ...         if n % x == 0:
    ...             print(n, 'equals', x, '*', n//x)
    ...             break
    ...     else:
    ...         # loop fell through without finding a factor
    ...         print(n, 'is a prime number')
    ...
    2 is a prime number
    3 is a prime number
    4 equals 2 * 2
    5 is a prime number
    6 equals 2 * 3
    7 is a prime number
    8 equals 2 * 4
    9 equals 3 * 3
Le bloc après `else` est exécuté si on ne sort pas de la boucle par un `break`
../..
Fonctions
=========
    >>> def fib(n):    # write Fibonacci series up to n
    ...     """Print a Fibonacci series up to n."""
    ...     a, b = 0, 1
    ...     while a < n:
    ...         print(a, end=' ')
    ...         a, b = b, a+b
    ...     print()
    ...
    >>> fib(2000)
    0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597

Une fonction est un objet

    >>> fib
    <function fib at 10042ed0>
    >>> f = fib
    >>> f(100)
    0 1 1 2 3 5 8 13 21 34 55 89
../..
Fonctions
=========
Par défaut, une fonction renvoie `None`

    >>> fib(0)
    >>> print(fib(0))
    None

`return` pour définir une valeur de retour

    >>> def fib2(n): # return Fibonacci series up to n
    ...     result = []
    ...     a, b = 0, 1
    ...     while a < n:
    ...         result.append(a)
    ...         a, b = b, a+b
    ...     return result
    ...
    >>> f100 = fib2(100)
    >>> f100
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
../..
Fonctions
=========
Arguments par défaut

    >>> def f(x, y=4):
    ...    return x+y
    ...
    >>> f(2)
    6
    >>> f(2,3)
    5
    
../..
Fonctions
=========
L'argument par défaut est calculé au moment de la définition de la fonction

    >>> i = 5
    >>> def f(arg=i):
    ...     print(arg)
    ...
    >>> i = 6
    >>> f()
    5

Il n'est évalué qu'une seule fois

    >>> def f(a, L=[]):
    ...    L.append(a)
    ...    return L
    ...
    >>> f(1)
    [1]
    >>> f(2)
    [1,2]
../..
Fonctions
=========
On peut appeler une fonction avec des mots-clés

    >>> def f(x,y):
    ...     return x-y
    ...
    >>> f(1,2)
    -1
    >>> f(y=6,x=2)
    -4

On ne peut pas donner deux fois le même argument

    >>> f(3,x=8)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: f() got multiple values for argument 'x'
../..
Fonctions
=========
Une fonction peut être appelée avec un nombre indéterminé d'arguments

    >>> def f(*args):
    ...    print(args) # tuple
    ...
    >>> f(1,2,'a')
    (1,2,'a')

et un nombre indéterminé de mots-clés

    >>> def f(**kw):
    ...    print(kw) # dictionnaire
    ...
    >>> f(x=0,y='a')
    {'x':0,'y':'a'}
../..
Fonctions
=========
Appel de fonction par "dépliage de tuple"

    >>> def f(x,y):
    ...     return x+y
    ...
    >>> t = (3,5)
    >>> f(*t)
    8
    
ou par "dépliage de dictionnaire"

    >>> d = {'x':3,'y':5}
    >>> f(**d)
    8
../..
Listes
======
Création par _list comprehensions_ (listes en extansion)

    >>> [ x for x in range(5) ]
    [0, 1, 2, 3, 4]
    >>> [ x*2 for x in range(5) ]
    [0, 2, 4, 6, 8]
    >>> [ x*2 for x in range(5) if x != 3 ]
    [0, 2, 4, 8]
    
../..
Listes
======
Imbrication de _list comprehensions_

    >>> matrix = [
    ...     [1, 2, 3, 4],
    ...     [5, 6, 7, 8],
    ...     [9, 10, 11, 12],
    ... ]
    ...
    >>> [[row[i] for row in matrix] for i in range(4)]
    [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
../..
`del`
=====
    >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
    >>> del a[0]
    >>> a
    [1, 66.25, 333, 333, 1234.5]
    >>> del a[2:4]
    >>> a
    [1, 66.25, 1234.5]
    >>> del a[:]
    >>> a
    []
../..
Tuples
======
C'est la virgule qui crée un tuple, pas la parenthèse

    >>> t = 1,2
    >>> t
    (1,2)
    >>> x = (1)
    >>> x
    1
    >>> x=(1,)
    >>> x
    (1,)
../..
`set` (ensemble)
================
Comme une liste, mais sans duplication ni ordre

    >>> panier = {'pomme', 'orange', 'pomme', 'poire', 'orange', 'banane'}
    >>> panier     # les doublons sont éliminés
    {'pomme', 'orange', 'poire', 'banane'}
    >>> 'orange' in panier
    True
    >>> 'abricot' in panier
    False

Création par _set comprehensions_

    >>> a = {x for x in 'abracadabra' if x not in 'abc'}
    >>> a
    {'r', 'd'}
../..
Dictionnaires
=============
Associe une clé (immuable : chaine, entier, tuple...) à une valeur

    >>> tel = {'jack': 4098, 'sape': 4139} # création
    >>> tel['guido'] = 4127                # nouvel élément
    >>> tel
    {'sape': 4139, 'guido': 4127, 'jack': 4098}
    >>> tel['jack']                        # accès par clé
    4098
    >>> del tel['sape']                    # suppression
    >>> tel['irv'] = 4127
    >>> tel
    {'guido': 4127, 'irv': 4127, 'jack': 4098}
    >>> 'guido' in tel                     # test d'appartenance
    True
    >>> 'jack' not in tel
    False

../..
Dictionnaires
=============
Itérateur sur les clés

    >>> list(tel.keys())
    ['irv', 'guido', 'jack']

Itérateur sur les valeurs

    >>> list(tel.values())
    [4127, 4127, 4098]

Itérateur sur les tuples (clé,valeur)

    >>> list(tel.items())
    [('irv', 4127), ('guido', 4127), ('jack', 4098)]
../..
Dictionnaires
=============
Itérer sur un dictionnaire c'est itérer sur ses clés

    >>> for key in tel:
    ...     print(key)
    ...
    irv
    guido
    jack

contrairement aux listes qui itèrent sur les valeurs

    >>> for value in [1,'a']:
    ...     print(value)
    ...
    1
    'a'

../..
Dictionnaires
=============
Construction par `dict`
    >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
    {'sape': 4139, 'jack': 4098, 'guido': 4127}

ou par _dict comprehensions_

    >>> {x: x**2 for x in (2, 4, 6)}
    {2: 4, 4: 16, 6: 36}
../..
Itérations
==========
`enumerate` pour itérer sur le tuple (rang,valeur)

    >>> for i,x in enumerate(['bordeaux','rennes']):
    ...     print(i,x)
    ...
    1 bordeaux
    2 rennes

plus "pythonique" que :

    >>> _list = ['bordeaux','rennes']
    >>> for i in range(len(_list)):
    ...     print(i,_list[i])
    ...
    1 bordeaux
    2 rennes
../..
Itérations
==========
`zip` pour itérer sur plusieurs séquences à la fois

    >>> questions = ['name', 'quest', 'favorite color']
    >>> answers = ['lancelot', 'the holy grail', 'blue']
    >>> for q, a in zip(questions, answers):
    ...     print('What is your '+q+'?  It is '+a)
    ...
    What is your name?  It is lancelot.
    What is your quest?  It is the holy grail.
    What is your favorite color?  It is blue.
../..
Itérations
==========
Pour affecter plusieurs variables à la fois

    >>> a,b,c = x

itère sur x et affecte les valeurs

    >>> a,b,c = range(3)
    >>> c
    2
    >>> a,b = {3:9,10:20}
    >>> b
    10
    
Il faut le même nombre de valeurs des deux côtés !
../..
Modules
=======
Sauvegarde dans un fichier fibo.py

    def fib(n):    # write Fibonacci series up to n
        a, b = 0, 1
        while b < n:
            print(b, end=' ')
            a, b = b, a+b
        print()
    
    def fib2(n): # return Fibonacci series up to n
        result = []
        a, b = 0, 1
        while b < n:
            result.append(b)
            a, b = b, a+b
        return result
../..
Modules
=======

`import` pour importer un module

    >>> import fibo
    >>> fibo.fib(1000)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
    >>> fibo.fib2(100)
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    >>> fibo.__name__
    'fibo'
../..
Modules
=======
`from ... import ...` pour importer des noms d'un module

    >>> from fibo import fib, fib2
    >>> fib(500)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377

`from ... import *` pour importer tous les noms d'un module

    >>> from fibo import *
    >>> fib2(100)
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
../..
Modules
=======
Recherche d'un module par son nom :
- dans la librairie standard
- puis dans le répertoire courant
../..
Packages
========
Pour structurer des librairies qui contiennent plusieurs modules

Organisation en répertoires qui contiennent un fichier *\_\_init\_\_.py*

    sound/                        
        __init__.py               
        formats/                  
            __init__.py
            wavread.py
            ...
        effects/                  
            __init__.py
            echo.py

    import sound
    import sound.formats
    from sound.formats import wavread
../..
La fonction `dir()`
===================
pour inspecter les noms définis par un module

    >>> import fibo, sys
    >>> dir(fibo)
    ['__name__', 'fib', 'fib2']

Sans arguments : liste les noms définis dans le module courant

    >>> a = [1, 2, 3, 4, 5]
    >>> import fibo
    >>> fib = fibo.fib
    >>> dir()
    ['__builtins__', '__doc__', '__file__', '__name__', 'a', 'fib', 'fibo']
../..
`str.format()`
==============
Permet de mettre en forme une chaine de caractères selon certains paramètres

Exemple :

    >>> print 'We are the {} who say "{}!"'.format('knights', 'Ni')
    We are the knights who say "Ni!"

Les séquences `{}` sont remplacées par les arguments de `format`

On peut spécifier le rang de l'argument à insérer :

    >>> print '{0} and {1}'.format('spam', 'eggs')
    spam and eggs
    >>> print '{1} and {0}'.format('spam', 'eggs')
    eggs and spam
../..
`str.format()`
==============
On peut spécifier des mots-clés

    >>> print 'This {food} is {adjective}.'.format(
    ...       food='spam', adjective='absolutely horrible')
    This spam is absolutely horrible.

et mélanger rang et mots-clés

    >>> print 'The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
    ...                                                    other='Georg')
    The story of Bill, Manfred, and Georg.
../..
`str.format()`
==============
On peut spécifier le nombre de décimales à utiliser

    >>> import math
    >>> print 'The value of PI is approximately {0:.3f}.'.format(math.pi)
    The value of PI is approximately 3.142

et le nombre minimal de caractères

    >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
    >>> for name, phone in table.items():
    ...     print '{0:10} ==> {1:10d}'.format(name, phone)
    ...
    Jack       ==>       4098
    Dcab       ==>       7678
    Sjoerd     ==>       4127
../..
Fichiers
========

<code>open(_filename,mode_)</code>

Le *mode* peut être
- 'r' : lecture seule (valeur par défaut)
- 'a' : écriture en fin de fichier
- 'w' : effacement si le fichier existe déjà, puis écriture

Sur Windows, ajouter 'r' pour ouvrir les fichiers en mode binaire
../..
Fichiers
========
<code>f.read(_nb_)</code> pour lire au moins _nb_ octets. Renvoie la chaine vide `''` en fin de fichier

`f.read()` pour lire tout le fichier

`f.readline()`: lit une ligne ; se termine par `\n`, ou `''` en fin de fichier

`f.readlines()` lit toutes les lignes et les met dans un tableau

Itération sur les lignes :

    for line in f:
        ...
../..
Fichiers
========
<code>f.write(_data_)</code> pour écrire la chaine _data_ dans le fichier

    >>> f.write('This is a test\n')

Pour écrire autre chose qu'une chaine, il faut d'abord convertir en chaine par `str()`

    >>> value = ('la réponse', 42)
    >>> s = str(value)
    >>> f.write(s)
../..
Fichiers
========
<code>f.seek(_x_)</code> positionne le pointeur à la position _x_

`f.tell()` renvoie la position courante du pointeur

`f.close()` ferme le fichier et libère les ressources associées

Utiliser de préférence `with` pour ne pas avoir à ouvrir et fermer explicitement

    >>> with open('/tmp/workfile', 'r') as f:
    ...     read_data = f.read()
    >>> f.closed
    True
../..
Sérialisation : le module `pickle`
==================================
Permet de transformer en chaine des objets complexes (listes, dictionnaires...) pour les stocker ou les envoyer sur le réseau

    import pickle
    pickle.dump(x, f) # écrit l'objet x dans le fichier f
    
    obj = pickle.load(f) # récupère l'objet x depuis le fichier f
../..
Erreurs et exceptions
=====================
Python distingue :
- les erreurs : détectées dans la phase d'analyse du programme
 - erreurs de syntaxe
 - erreur d'indentation
- les exceptions : surviennent pendant l'exécution d'un programme
../..
Erreurs
=======
`SyntaxError`
    >>> while True print 'Hello world'
      File "<stdin>", line 1, in ?
        while True print 'Hello world'
                       ^
    SyntaxError: invalid syntax

`IndentationError`
    >>> for i in range(5):
    ... print i
      File "<stdin>", line 2
        print i
            ^
    IndentationError: expected an indented block

../..
Exceptions
==========
Exemples :

    >>> 10 * (1/0)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    ZeroDivisionError: integer division or modulo by zero
    
    >>> 4 + spam*3
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    NameError: name 'spam' is not defined
    
    >>> '2' + 2
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: cannot concatenate 'str' and 'int' objects
../..
Exceptions
==========
`try ... except` pour gérer des exceptions

    >>> while True:
    ...     try:
    ...         x = int(raw_input("Veuillez entrer un nombre: "))
    ...         break
    ...     except ValueError:
    ...         print "Ce n'est pas un nombre valide.  Recommencer..."
    ...

Si une instruction du bloc `try` déclenche une exception, on arrête l'exécution du bloc

Si l'exception est du type spécifié dans `except` on exécute le bloc de cet `except`
../..
Exceptions
==========
Variantes de `except` :

    try:
        ...
    except IOError:
        ...
    except (TypeError, ValueError): # plusieurs types d'exceptions
        ...
    except:        # toutes les exceptions non encore gérées
        ...
../..
Exceptions
==========
`else` si aucune exception n'a été déclenchée

    try:
        x = 1
    except:
        print('erreur')
    else:
        print('ok')
../..
Exceptions
==========
`as` pour récupérer l'objet exception

    >>> x = [6]
    ... try:
    ...     x[2]
    ... except IndexError as exc:
    ...    print('erreur index',exc)
    ...
    ('erreur index', IndexError('list index out of range',))

L'objet `exc` est une _instance_ de la _classe_ `IndexError`
../..
Exceptions
==========
`raise` pour déclencher des exceptions

    >>> raise NameError('HiThere')
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    NameError: HiThere
    
Sans argument : re-déclenche la dernière exception gérée

    >>> try:
    ...     raise NameError('HiThere')
    ... except NameError:
    ...     print 'An exception flew by!'
    ...     raise
    ...
    An exception flew by!
    Traceback (most recent call last):
      File "<stdin>", line 2, in ?
    NameError: HiThere
    
../..
Exceptions
==========
Les modules peuvent définir des _classes_ d'exception spécifiques, dérivées de la classe `Exception`

    >>> class MyError(Exception):
    ...     def __init__(self, value):
    ...         self.value = value
    ...
    >>> try:
    ...     raise MyError(4)
    ... except MyError as e:
    ...     print 'My exception occurred, value:', e.value
    ...
    My exception occurred, value: 4

`MyError(4)` crée une _instance_ de la classe `MyError` en passant l'argument `4`

La méthode `__init__(self, value)` initialise l'instance avec l'argument _value_
../..

Exceptions
==========
`finally` pour exécuter un code qu'il y ait eu exception ou pas

Si une exception n'a pas été gérée, elle est déclenchée après `finally`

    >>> x = [5]
    >>> try:
    ...     print(x[2])
    ... finally:
    ...     print('Goodbye, world!')
    ...
    Goodbye, world!
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
    IndexError: list index out of range

../..
Exceptions
==========
    >>> def divide(x, y):
    ...     try:
    ...         result = x / y
    ...     except ZeroDivisionError:
    ...         print "division by zero!"
    ...     else:
    ...         print "result is", result
    ...     finally:
    ...         print "executing finally clause"
    ...
    >>> divide(2, 1)
    result is 2
    executing finally clause

    >>> divide(2, 0)
    division by zero!
    executing finally clause

    >>> divide("2", "1")
    executing finally clause
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
      File "<stdin>", line 3, in divide
    TypeError: unsupported operand type(s) for /: 'str' and 'str'

../..
Espaces de noms
===============
Permet de définir et d'utiliser le même nom dans des contextes différents

Variables globales / locales

    >>> a, b = 1, 2 # définit deux variables dans l'espace de noms global
    >>> def f():
    ...    global b # la variable b est globale
    ...    a = 3    # définit une variable a dans l'espace de noms 
    ...             # local de la fonction f
    ...    b = 99
    ...    print(a)
    ...
    >>> f()
    3
    >>> a
    1
    >>> b
    99
../..
Espaces de noms
===============

    x = 0

    def f(x):
        import Z

    import X
    
    from Y import A
    
    for i in range(5):
        j = 2 * i

définit les noms `x, f, X, A, i, j` dans l'espace de noms global ; `x, Z` dans l'espace de noms de f

NB : le nom `Y` n'est __pas__ dans l'espace de noms
../..
Espaces de noms
===============
A l'exécution, quand l'interpréteur rencontre un nom, il cherche dans l'espace de nom le plus proche, puis "remonte" jusqu'aux noms intégrés

    a = 6
    def f():
        b = 8
        def g(n):
            print(n)
            print(b)
            print(a)
        g(8)
 
Dans l'exécution de g : 
- pas de nom `print` dans les espaces globaux ni locaux, mais `print` est un mot clé de Python
- le nom `n` est dans l'espace de noms de g
- pas de nom `b` dans l'espace de noms de g, on remonte jusqu'à l'espace de noms de f
- pas de nom `a` dans l'espace de noms de g ni de f, on remonte jusqu'à l'espace de noms global
../..
Classes
=======
Définis par le mot clé `class`

    class ClassName:
        <statement-1>
        .
        .
        .
        <statement-N>

Le nom `ClassName` est ajouté dans l'espace de noms où la classe est définie

Une classe possède son propre espace de noms
../..
Classes
=======

    >>> class MyClass:
    ...    i = 12345
    ...
    >>> print(MyClass.i)

Les noms définis dans `MyClass` (_attributs_) sont accessibles depuis l'espace de noms "supérieur" par des _noms qualifiés_

On peut modifier les attributs de la classe

    >>> MyClass.i = 23456
    
../..
Classes
=======
Pour créer des instances d'une classe, on l'utilise comme une fonction :

    >>> class MyClass:
    ...    i = 12345
    ...
    >>> x = MyClass()

L'instance possède les mêmes attributs que la classe

    >>> x.i
    12345
../..
Classes
=======
Les _fonctions_ définies dans la classe deviennent les _méthodes_ des instances de cette classe

Par convention, on les écrit avec l'instance comme premier argument, appelé `self`

    >>> class MyClass:
    ...     def f(self):
    ...         print('function f')
    ...     def greet(self,name):
    ...         print('hello, ',name)
    ...
    >>> x = MyClass()
    >>> x.f()
    hello
    >>> x.greet('world')
    hello, world

`x.greet('world')` est équivalent à `MyClass.greet(x,'world')`

../..
Classes
=======
Pour initialiser une instance avec des attributs spécifiques : fonction spéciale `__init__()`

    >>> class MyClass:
    ...     def __init__(self):
    ...         self.data = []
    ...
    >>> x = MyClass()
    >>> x.data
    []

../..
Classes
=======
On peut passer des arguments à la fonction `__init__`

    >>> class Complex:
    ...     def __init__(self, realpart, imagpart):
    ...         self.r = realpart
    ...         self.i = imagpart
    ...
    >>> x = Complex(3.0, -4.5)
    >>> x.r, x.i
    (3.0, -4.5)
../..
Classes
=======
Les méthodes peuvent appeler d'autres méthodes

    class Bag:

        def __init__(self):
            self.data = []

        def add(self, x):
            self.data.append(x)

        def addtwice(self, x):
            self.add(x)
            self.add(x)
../..
Héritage
========

    class DerivedClass(BaseClass):
        <statement-1>
        .
        .
        .
        <statement-N>

`DerivedClass` _hérite_, ou est _dérivée_, ou est une _sous-classe_ de `BaseClass`
../..
Héritage
========

    >>> class A:
    ...     x = 0
    ...
    >>> class B(A):
    ...     y = 1
    ...
    >>> obj = B()
    >>> obj.y
    1
    >>> obj.x
    0

La recherche (_résolution_) d'attribut est exécutée dans la classe B, puis dans la classe A dont B hérite
../..
Héritage
========
Une sous-classe peut réécrire (_surcharger_) les fonctions de la classe dont elle hérite

    class A:
        x = 0
        def show(self):
            print('je suis A')

    classe B(A):
        def show(self):
            print(je suis B')
../..
Héritage
========
On peut utiliser les fonctions de A dans les fonctions de B

    class A:
        def __init__(self, x):
            self.x = x**2

    class B(A):
        def __init__(self,x,y):
            A.__init__(self,x)
            self.y = y    
../..
Héritage
========
Héritage multiple

    class DerivedClassName(Base1, Base2, Base3):
        <statement-1>
        .
        .
        .
        <statement-N>
../..
Héritage
========
<code>issubclass(_A,B_)</code> teste si la classe _A_ hérite de la classe _B_

<code>isinstance(_obj,A_)</code> teste si l'objet _obj_ est une instance de _A_ ou d'une classe dont _A_ hérite

../..
Itérateurs
==========
Utilisés très fréquemment en Python

    for element in [1, 2, 3]:
        print element
    for element in (1, 2, 3):
        print element
    for key in {'one':1, 'two':2}:
        print key
    for char in "123":
        print char
    for line in open("myfile.txt"):
        print line
../..
Itérateurs
==========
Utilisent les fonctions intégrées 
- <code>iter(_instance_)</code> : retourne un itérateur sur l'_instance_
- <code>next(_iterateur_)</code> : retourne le prochain élément de l'itérateur, ou déclenche l'exception `StopIteration`

    >>> s = 'abc'
    >>> it = iter(s)
    >>> it
    <iterator object at 0x00A1DB50>
    >>> it.next()
    'a'
    >>> it.next()
    'b'
    >>> it.next()
    'c'
    >>> it.next()
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
        it.next()
    StopIteration
../..
Itérateurs
==========
`iterator = iter(instance)` équivaut à `iterator = instance.__iter__()`

`item = next(iterator)` équivaut à `item = iterator.next()`

Pour pouvoir itérer sur les instances d'une classe il faut lui définir une fonction `__iter__`, qui renvoie un objet qui possède une méthode `next`

    class Reverse:
        """Iterator for looping over a sequence backwards."""
        def __init__(self, data):
            self.data = data
            self.index = len(data)
        def __iter__(self):
            return self
        def next(self):
            if self.index == 0:
                raise StopIteration
            self.index = self.index - 1
            return self.data[self.index]
../..
Generateurs
===========
Création automatique d'itérateurs : fonctions qui utilisent `yield` au lieu de `return`

    >>> def squares(n):
    ...     """Itérateur sur les carrés des nombres de 0 à n"""
    ...     for i in range(n):
    ...         yield i*i
    ...
    >>> for x in squares(5):
    ...     print(x)
    ...
    0
    1
    4
    9
    16
../..
Generator expressions
=====================
Simplifie le passage d'argument à une fonction qui attend un itérateur

    >>> sum(i*i for i in range(10))                 # sum of squares
    285
    
    >>> xvec = [10, 20, 30]
    >>> yvec = [7, 5, 3]
    >>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
    260
    
    >>> unique_words = set(word  for line in page  for word in line.split())
    
    
