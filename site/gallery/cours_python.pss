@title Introduction à Python
@pagenum True

Introduction à Python
=====================

<h2 style="padding-top:100px;padding-left:100px;">Adapté du [Tutoriel Python](http://docs.python.org/2/tutorial/index.html)</h2>
<h3 style="padding-top:50px;padding-left:100px;">par Pierre Quentel pierre.quentel@gmail.com</h3>


../..
Historique
==========
- créé en 1989 par Guido van Rossum

- version 2.0 en 2000
 - version courante 2.7.6

- version 3.0 en 2008 (quelques incompatibilités)
 - version courante 3.3.3
 - plus cohérent, "propre", meilleur support d'Unicode

- recommandation : __choisir Python3 pour les nouveaux projets__
 - sauf dépendence incontournable à une librairie pas encore migrée en Python 3
 
../..
Caractéristiques
================
- facile à apprendre
- structures de données de haut niveau
- orienté objet
- interprété
- extensible
- Open Source
- disponible et portable "tel quel" sur toutes les plateformes
- pratique plus que puriste
- accent sur la lisibilité
- typage fort, mais non déclaré
- puissant : coeur minimaliste, mais bibliothèque très étendue (UI, web, fichiers, bases de données, manipulation de texte...)
../..
Popularité
==========
<img src='tiobe.png' height=400>
../..
Popularité
==========
<img src='Languages_2013-12.png' height=400>
../..
Popularité
==========
Projets créés sur Github en 2013

<pre>
Rank    Language      # Repositories Created
1       JavaScript    264131
2       Ruby          218812
3       Java          157618
4       PHP           114384
5       Python         95002
6       C++            78327
7       C              67706
8       Objective-C    36344
9       C#             32170
10      Shell          28561
</pre>
../..
Popularité
==========
Largement utilisé par Google (dont GvR était salarié jusqu'en 2012, maintenant chez DropBox), sur Youtube

Mercurial est écrit en Python

Web frameworks : Zope, Django

[Success stories](http://www.python.org/about/success/)

../..
Installation
============
Aller sur le [site](http://python.org) et suivre les instructions

L'installation crée une commande _python_ dans l'invite de commande, qui lance l'interpréteur interactif

<img src="python.png" height=300>
../..
Ressources
==========
- la documentation Python : [site Python](http://docs.python.org/2/), doc Windows
- forums : [comp.lang.python](https://groups.google.com/forum/?fromgroups#!forum/comp.lang.python), [comp.lang.python.fr](https://groups.google.com/forum/?fromgroups#!forum/fr.comp.lang.python)
- [stackoverflow](http://stackoverflow.com/)

- [Python Package Index](http://pypi.python.org)
- [The Python Cookbook](http://aspn.activestate.com/ASPN/Python/Cookbook/)
../..
Commentaires
============
Introduits par #

    `python
    # this is the first comment
    SPAM = 1                 # and this is the second comment
                             # ... and now a third!
    STRING = "# This is not a comment."
../..
Définition de noms
==================

    >>> width = 20
    >>> width += 10
    >>> width
    30
    >>> height = 5*9
    
    >>> x = y = z = 0
    
    >>> tax = 0.125
    >>> ht = 100.50
    >>> ttc = ht * (1+tax)
    >>> round(ttc, 2)
    113,06
../..
Chaines de caractères
=====================
Utilise ' ou "
    `python
    'spam eggs'
    "spam eggs"

    "doesn't"
    '"Yes," he said.'

<code>\</code> pour "échappement"

    `python
    'doesn\'t'
    "\"Yes,\" he said."
    '"Isn\'t," she said.'
../..
Chaines de caractères
=====================
\ pour continuer une ligne
    `python
    hello = "This is a rather long string containing\n\
    several lines of text just as you would do in C.\n\
        Note that whitespace at the beginning of the line is\
     significant."

""" sur plusieurs lignes
    `python
    print """
    Usage: thingy [OPTIONS]
         -h                        Display this usage message
         -H hostname               Hostname to connect to
    """
../..
Chaines de caractères
=====================
Mode par défaut :
    >>> word = 'a\nb'
    >>> print(word)
    a
    b
    
Mode brut :
    >>> word = r'a\nb'
    >>> print(word)
    a\nb
    
../..
Chaines de caractères
=====================
Concaténation par +, duplication par *

    >>> word = 'Help' + 'A'
    >>> word
    'HelpA'
    >>> '<' + word*5 + '>'
    '<HelpAHelpAHelpAHelpAHelpA>'
../..
Chaines de caractères
=====================
Accès à un caractère par index
------------------------------
     +---+---+---+---+---+
     | H | e | l | p | A |
     +---+---+---+---+---+
       0   1   2   3   4
      -5  -4  -3  -2  -1
            
    >>> word[4]
    'A'
    >>> word[-2]
    'p'
../..
Chaines de caractères
=====================
Tranches
--------
     +---+---+---+---+---+
     | H | e | l | p | A |
     +---+---+---+---+---+
     0   1   2   3   4   5
    -5  -4  -3  -2  -1
    >>> word[0:2]
    'He'
    >>> word[2:4]
    'lp'
    >>> word[:2]
    'He'
    >>> word[3:]
    'pA'
../..
Chaines de caractères
=====================
Test d'appartenance

    >>> s = 'abcde'
    >>> 'a' in s
    True
    >>> 'b' not in s
    False
    >>> 'x' in s
    False
    
../..
Chaines de caractères
=====================
Les chaines sont immuables

    >>> word = 'HelpA'
    >>> word[1]='a'
    TypeError: 'str' object does not support item assignment
Longueur d'une chaine

    >>> word = 'anticonstitutionnellement'
    >>> len(word)
    25
../..
Listes
======
    >>> a = ['spam', 'eggs', 100, 1234]
    >>> a
    ['spam', 'eggs', 100, 1234]

Accès par index ou par tranche

    >>> a[0]
    'spam'
    >>> a[3]
    1234
    >>> a[-2]
    100
    >>> a[1:-1]
    ['eggs', 100]
../..
Listes
======
Concaténation par +, duplication par *

    >>> 3*a[:3] + ['Boo!']
    ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']        

Affectation et clonage

    >>> a = [0,1]
    >>> b = a       # les noms 'a' et 'b' sont liés au même objet
    >>> b[0] = 9    # toute modification sur b modifie aussi a
    >>> a
    [9, 1]
    >>> b = a[:]    # clonage : création d'un objet différent de a
    >>> b[0] = 1
    >>> a
    [9, 1]
../..
Listes
======
Les listes sont mutables

    >>> a
    ['spam', 'eggs', 100, 1234]
    >>> a[2] = a[2] + 23
    >>> a
    ['spam', 'eggs', 123, 1234]
../..
Listes
======
Longueur d'une chaine par `len`

    >>> a = ['a', 'b', 'c', 'd']
    >>> len(a)
    4
../..
Listes
======
Transformer une listes de chaines en une seule chaine : méthode `join` appliquée au _séparateur_

    >>> a = ["O rage","ô désespoir","ô vieillesse ennemie"]
    >>> ' ! '.join(a)
    'O rage ! ô désespoir ! ô vieillesse ennemie'

Découper une chaine de caractères en éléments d'une liste

    >>> s = "La cigale et la fourmi"
    >>> s.split()
    ['La', 'cigale', 'et', 'la', 'fourmi']
    >>> s = "et un ! et deux ! et trois zéros !"
    >>> s.split('!')
    ['et un ', ' et deux ', ' et trois zéros ', '']
    
../..
Listes
======
Une liste peut contenir d'autres listes
    >>> q = [2, 3]
    >>> p = [1, q, 4]
    >>> len(p)
    3
    >>> p[1]
    [2, 3]
    >>> p[1][0]
    2
../..
Listes
======
Ajout d'un élément à la fin d'une liste par `append`
    >>> q = [2, 3]
    >>> q.append('xtra')
    >>> q
    [2, 3, 'xtra']

Insertion d'un élément à une position donnée par `insert`
    >>> q.insert(1,'new')
    >>> q
    [2, 'new', 3, 'xtra']
    >>>
../..
Tuples
======
Comme une liste, mais immuable

    >>> t = (1,2,'a')
    >>> t[1]
    2
    >>> t[2] = 'b'
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'tuple' object does not support item assignment

../..
Premiers pas en programmation
=============================
Suite de Fibonacci

    >>> a, b = 0, 1
    >>> while b < 10:
    ...     print(b)
    ...     a, b = b, a+b
    ...
    1
    1
    2
    3
    5
    8
A noter :
- assignement multiple : `a, b = 0, 1`
- indentation
 - utiliser de préférence 4 espaces
- boucle `while`
../..
La fonction `print`
===================
    >>> i = 256*256
    >>> print('La valeur de i est', i)
    La valeur de i est 65536

__[Python 3]__ Le mot-clé *end*

    >>> a, b = 0, 1
    >>> while b < 1000:
    ...     print(b, end=',')
    ...     a, b = b, a+b
    ...
    1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
../..
Conditions : `if, elif, else`
=============================
    >>> x = int(input("Please enter an integer: ")) # "raw_input" en Python 2
    Please enter an integer: 42
    >>> if x < 0:
    ...      x = 0
    ...      print('Negative changed to zero')
    ... elif x == 0:
    ...      print('Zero')
    ... elif x == 1:
    ...      print('Single')
    ... else:
    ...      print('More')
    ...
    More

nb : pas de "switch / case"
../..
Boucle `for`
============
Un des outils les plus puissants de Python
    >>> a = ['cat', 'window', 'defenestrate']
    >>> for x in a:
    ...     print(x, len(x))
    ...
    cat 3
    window 6
    defenestrate 12

L'itération par `for ... in` permet de manipuler des *valeurs* plutôt que des *index*

../..
La fonction `range`
===================
    >>> for i in range(5):
    ...     print(i)
    ...
    0
    1
    2
    3
    4

syntaxe : `range(start,stop,step)`
../..
Itérateurs
==========
__[Python 2]__

    >>> range(5)
    [0, 1, 2, 3, 4]
> `range` renvoie une liste

----
__[Python 3]__
    >>> range(5)
    range(0, 5)

> `range` renvoie un _itérateur_

> Dans `for x in A`, *A* est un itérateur

> Certaines fonctions prennent un itérateur comme argument, par exemple `list`

    >>> list(range(5))
    [0, 1, 2, 3, 4]
../..
`continue`
==========
    >>> for num in range(2, 6):
    ...     if num % 2 == 0:
    ...         print("Nombre pair", num)
    ...         continue
    Nombre pair 2
    Nombre pair 4
../..
`break` et `else` dans une boucle
=================================
    >>> for n in range(2, 10):
    ...     for x in range(2, n):
    ...         if n % x == 0: # x divise n
    ...             print(n, '=', x, '*', n//x)
    ...             break
    ...     else: # nombre premier
    ...         print(n, 'est un nombre premier')
    ...
    2 est un nombre premier
    3 est un nombre premier
    4 = 2 * 2
    5 est un nombre premier
    6 = 2 * 3
    7 est un nombre premier
    8 = 2 * 4
    9 = 3 * 3
Le bloc après `else` est exécuté si on ne sort pas de la boucle par un `break`
../..
Fonctions
=========
    >>> def fib(n):
    ...     """Ecrit la suite de Fibonacci jusqu'à n."""
    ...     a, b = 0, 1
    ...     while a < n:
    ...         print(a, end=' ')
    ...         a, b = b, a+b
    ...     print()
    ...
    >>> fib(2000)
    0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597

../..
Fonctions
=========
Par défaut, une fonction renvoie `None`

    >>> fib(0)
    >>> print(fib(0))
    None

`return` pour définir une ou plusieurs valeur(s) de retour

    >>> def fib2(n): # renvoie la suite de Fibonacci jusqu'à n
    ...     result = []
    ...     a, b = 0, 1
    ...     while a < n:
    ...         result.append(a)
    ...         a, b = b, a+b
    ...     return result
    ...
    >>> f100 = fib2(100)
    >>> f100
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
../..
Fonctions
=========
Définition d'arguments par défaut

    >>> def f(x, y=4):
    ...    return x+y
    ...
    >>> f(2)
    6
    >>> f(2,3)
    5
    
../..
Fonctions
=========
L'argument par défaut est calculé au moment de la définition de la fonction

    >>> i = 5
    >>> def f(arg=i):
    ...     print(arg)
    ...
    >>> i = 6
    >>> f()
    5

Il n'est évalué qu'une seule fois

    >>> def f(a, L=[]):
    ...    L.append(a)
    ...    return L
    ...
    >>> f(1)
    [1]
    >>> f(2)
    [1,2]
../..
Fonctions
=========

    >>> def f(x,y):
    ...     return x-y
    ...

On peut appeler une fonction avec des _arguments_

    >>> f(1,2)
    -1

ou des _mots-clés_

    >>> f(y=6,x=2)
    -4

On ne peut pas donner deux fois le même argument

    >>> f(3,x=8)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: f() got multiple values for argument 'x'
../..
Fonctions
=========
Une fonction peut être appelée avec un nombre indéterminé d'arguments

    >>> def f(*args):
    ...    print(args) # tuple
    ...
    >>> f(1,2,'a')
    (1,2,'a')

et un nombre indéterminé de mots-clés

    >>> def f(**kw):
    ...    print(kw) # dictionnaire
    ...
    >>> f(x=0,y='a')
    {'x':0,'y':'a'}
../..
Fonctions
=========
Appel de fonction par "dépliage de tuple"

    >>> def f(x,y):
    ...     return x+y
    ...
    >>> t = (3,5)
    >>> f(*t)
    8
    
ou par "dépliage de dictionnaire"

    >>> d = {'x':3,'y':5}
    >>> f(**d)
    8
../..
Listes
======
Création par _list comprehensions_ (listes en extansion)

    >>> [ x for x in range(5) ]
    [0, 1, 2, 3, 4]
    >>> [ x*2 for x in range(5) ]
    [0, 2, 4, 6, 8]
    >>> [ x*2 for x in range(5) if x != 3 ]
    [0, 2, 4, 8]
    
../..
Listes
======
Imbrication de _list comprehensions_

    >>> matrix = [
    ...     [1, 2, 3, 4],
    ...     [5, 6, 7, 8],
    ...     [9, 10, 11, 12],
    ... ]
    ...
    >>> [[row[i] for row in matrix] for i in range(4)]
    [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
../..
`del`
=====
    >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
    >>> del a[0]
    >>> a
    [1, 66.25, 333, 333, 1234.5]
    >>> del a[2:4]
    >>> a
    [1, 66.25, 1234.5]
    >>> del a[:]
    >>> a
    []
../..
Tuples
======
C'est la virgule qui crée un tuple, pas la parenthèse

    >>> t = 1,2
    >>> t
    (1,2)
    >>> x = (1)
    >>> x
    1
    >>> x=(1,)
    >>> x
    (1,)
../..
Ensemble
========
Comme une liste, mais sans duplication ni ordre

    >>> panier = {'pomme', 'orange', 'pomme', 'poire', 'orange', 'banane'}
    >>> panier     # les doublons sont éliminés
    {'banane', 'poire', 'pomme', 'orange'} # Python 3
    >>> 'orange' in panier
    True
    >>> 'abricot' in panier
    False

ou création par _set comprehensions_

    >>> a = {x for x in 'abracadabra' if x not in 'abc'}
    >>> a
    {'r', 'd'}
../..
Ensemble
========

    >>> panier.add('abricot')
    >>> panier
    {'banane', 'poire', 'abricot', 'pomme', 'orange'}

Intersection d'ensembles
    >>> couleurs = {'bleu','jaune','orange'}
    >>> panier & couleurs
    {'orange'}   
Union
    >>> panier | couleurs
    {'jaune', 'poire', 'banane', 'abricot', 'bleu', 'pomme', 'orange'}
../..
Dictionnaires
=============
Associe une clé (immuable : chaine, entier, tuple...) à une valeur

    >>> tel = {'jack': 4098, 'sape': 4139} # création
    >>> tel['guido'] = 4127                # nouvel élément
    >>> tel
    {'sape': 4139, 'guido': 4127, 'jack': 4098}
    >>> tel['jack']                        # accès par clé
    4098
    >>> tel['jack'] = 4099                 # changement de valeur
    >>> del tel['sape']                    # suppression
    >>> tel['irv'] = 4127
    >>> tel
    {'guido': 4127, 'irv': 4127, 'jack': 4099}
    >>> 'guido' in tel                     # test d'appartenance (clé)
    True
    >>> 'jack' not in tel
    False

../..
Dictionnaires
=============

`tel.keys()` renvoie :
- la liste des clés en Python 2
- un itérateur sur la liste des clés en Python 3

Même chose pour `tel.values()` (valeurs) et `tel.items()` (tuples clé,valeur)

    >>> for key,value in tel.items():
    ...     print key,"'s number is ",value  # Python 2
    ...
    jack 's number is 4099
    irv 's number is 4127
    guido 's number is 4127

../..
Dictionnaires
=============
Itérer sur un dictionnaire c'est itérer sur ses clés

    >>> for key in tel:
    ...     print(key)
    ...
    irv
    guido
    jack

contrairement aux listes qui itèrent sur les valeurs

    >>> for value in [1,'a']:
    ...     print(value)
    ...
    1
    'a'

../..
Dictionnaires
=============
Construction par `dict`
    >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
    {'sape': 4139, 'jack': 4098, 'guido': 4127}

ou par _dict comprehensions_

    >>> {x: x**2 for x in (2, 4, 6)}
    {2: 4, 4: 16, 6: 36}
../..
Itérations
==========
`enumerate` pour itérer sur le tuple (rang,valeur)

    >>> for i,x in enumerate(['bordeaux','rennes']):
    ...     print(i,x)
    ...
    0 bordeaux
    1 rennes

plus "pythonique" que :

    >>> _list = ['bordeaux','rennes']
    >>> for i in range(len(_list)):   # ouh le débutant !
    ...     print(i,_list[i])
    ...
    0 bordeaux
    1 rennes
../..
Itérations
==========
`zip` pour itérer sur plusieurs séquences à la fois

    >>> questions = ['name', 'quest', 'favorite color']
    >>> answers = ['lancelot', 'the holy grail', 'blue']
    >>> for q, a in zip(questions, answers):
    ...     print('What is your '+q+'?  It is '+a)
    ...
    What is your name?  It is lancelot.
    What is your quest?  It is the holy grail.
    What is your favorite color?  It is blue.
../..
Itérations
==========
Pour affecter plusieurs variables à la fois

    >>> a,b,c = x

itère sur x et affecte les valeurs

    >>> a,b,c = range(3)
    >>> c
    2
    >>> a,b = {3:9,10:20}
    >>> b
    10
    
Il faut le même nombre de valeurs des deux côtés !
../..
Scripts
=======
Enregistrement du programme dans un fichier _script.py_

    `python
    for i in range(1):
        print(i)

Dans l'invite de commandes, aller dans le répertoire de _script.py_ et exécuter

    C:\test python>python script.py
    0
    1
    2
    3
    4
    
../..
Modules
=======
Sauvegarde dans un fichier fibo.py

    `python
    def fib(n):    # write Fibonacci series up to n
        a, b = 0, 1
        while b < n:
            print(b, end=' ')
            a, b = b, a+b
        print()
    
    def fib2(n): # return Fibonacci series up to n
        result = []
        a, b = 0, 1
        while b < n:
            result.append(b)
            a, b = b, a+b
        return result
../..
Modules
=======

`import` pour importer un module

    >>> import fibo
    >>> fibo.fib(1000)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
    >>> fibo.fib2(100)
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    >>> fibo.__name__
    'fibo'
../..
Modules
=======
`from X import n1, n2...` pour importer des noms d'un module

    >>> from fibo import fib, fib2
    >>> fib(500)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377

`from X import *` pour importer tous les noms du module _(attention aux conflits de noms !)_

    >>> from fibo import *
    >>> fib2(100)
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
../..
Modules
=======
Recherche d'un module par son nom :
- dans la librairie standard
- puis dans le répertoire courant
../..
Packages
========
Pour structurer des librairies qui contiennent plusieurs modules

Organisation en répertoires qui contiennent un fichier *\_\_init\_\_.py*

    sound/                        
        __init__.py               
        formats/                  
            __init__.py
            wavread.py
            ...
        effects/                  
            __init__.py
            echo.py

    import sound
    import sound.formats
    from sound.formats import wavread
../..
La fonction `dir()`
===================
pour inspecter les noms définis par un module

    >>> import fibo, sys
    >>> dir(fibo)
    ['__name__', 'fib', 'fib2']

Sans arguments : liste les noms définis dans le module courant

    >>> a = [1, 2, 3, 4, 5]
    >>> import fibo
    >>> fib = fibo.fib
    >>> dir()
    ['__builtins__', '__doc__', '__file__', '__name__', 'a', 'fib', 'fibo']
../..
`str.format()`
==============
Permet de mettre en forme une chaine de caractères selon certains paramètres

Exemple :

    >>> print 'We are the {} who say "{}!"'.format('knights', 'Ni')
    We are the knights who say "Ni!"

Les séquences `{}` sont remplacées par les arguments de `format`

On peut spécifier le rang de l'argument à insérer :

    >>> print '{0} and {1}'.format('spam', 'eggs')
    spam and eggs
    >>> print '{1} and {0}'.format('spam', 'eggs')
    eggs and spam
../..
`str.format()`
==============
On peut spécifier des mots-clés

    >>> print 'This {food} is {adjective}.'.format(
    ...       food='spam', adjective='absolutely horrible')
    This spam is absolutely horrible.

et mélanger rang et mots-clés

    >>> print 'The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
    ...                                                    other='Georg')
    The story of Bill, Manfred, and Georg.
../..
`str.format()`
==============
On peut spécifier le nombre de décimales à utiliser

    >>> import math
    >>> print 'The value of PI is approximately {0:.3f}.'.format(math.pi)
    The value of PI is approximately 3.142

et le nombre minimal de caractères

    >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
    >>> for name, phone in table.items():
    ...     print '{0:10} ==> {1:10d}'.format(name, phone)
    ...
    Jack       ==>       4098
    Dcab       ==>       7678
    Sjoerd     ==>       4127
../..
Fichiers
========

<code>open(_filename,mode_)</code>

Le *mode* peut être
- 'r' : lecture seule (valeur par défaut)
- 'a' : écriture en fin de fichier
- 'w' : effacement si le fichier existe déjà, puis écriture

Sur Windows, ajouter 'b' pour ouvrir les fichiers en mode binaire ('rb', 'wb'...)
../..
Fichiers
========
<code>f.read(_nb_)</code> pour lire au plus _nb_ octets. Renvoie la chaine vide `''` en fin de fichier

`f.read()` pour lire tout le fichier

`f.readline()`: lit une ligne ; se termine par `\n`, ou `''` en fin de fichier

`f.readlines()` lit toutes les lignes et les met dans un tableau

Itération sur les lignes :

    `python
    for line in f:
        ...
../..
Fichiers
========
<code>f.write(_data_)</code> pour écrire la chaine _data_ dans le fichier

    >>> f.write('This is a test\n')

Pour écrire autre chose qu'une chaine, il faut d'abord convertir en chaine par `str()`

    >>> f.write(42)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: expected a character buffer object
    >>> out.write(str(42))

../..
Fichiers
========
<code>f.seek(_x_)</code> positionne le pointeur à la position _x_

`f.tell()` renvoie la position courante du pointeur

`f.close()` ferme le fichier et libère les ressources associées

Utiliser de préférence `with` pour ne pas avoir à fermer explicitement

    >>> with open('/tmp/workfile', 'r') as f:
    ...     read_data = f.read()
    >>> f.closed
    True
../..
Sérialisation : le module `pickle`
==================================
Permet de transformer en chaine des objets complexes (listes, dictionnaires...) pour les stocker ou les envoyer sur le réseau

    `python
    import pickle
    pickle.dump(x, f) # écrit l'objet x dans le fichier f
    
    obj = pickle.load(f) # récupère l'objet x depuis le fichier f
../..
Erreurs et exceptions
=====================
Python distingue :

- les erreurs : détectées dans la phase d'analyse du programme
 - erreurs de syntaxe
 - erreur d'indentation

- les exceptions : surviennent pendant l'exécution d'un programme
../..
Erreurs
=======
`SyntaxError`
    >>> while True print 'Hello world'
      File "<stdin>", line 1, in ?
        while True print 'Hello world'
                       ^
    SyntaxError: invalid syntax

`IndentationError`
    >>> for i in range(5):
    ... print i
      File "<stdin>", line 2
        print i
            ^
    IndentationError: expected an indented block

../..
Exceptions
==========
Exemples :

    >>> 10 * (1/0)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    ZeroDivisionError: integer division or modulo by zero
    
    >>> 4 + spam*3
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    NameError: name 'spam' is not defined
    
    >>> '2' + 2
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: cannot concatenate 'str' and 'int' objects
../..
Exceptions
==========
`try ... except` pour gérer des exceptions

    >>> while True:
    ...     try:
    ...         x = int(raw_input("Veuillez entrer un nombre: "))
    ...         break
    ...     except ValueError:
    ...         print "Ce n'est pas un nombre valide.  Recommencer..."
    ...

Si une instruction du bloc `try` déclenche une exception, on arrête l'exécution du bloc

Si l'exception est du type spécifié dans `except` on exécute le bloc de cet `except`
../..
Exceptions
==========
Variantes de `except` :

    `python
    try:
        ...
    except IOError:
        ...
    except (TypeError, ValueError): # plusieurs types d'exceptions
        ...
    except:        # toutes les exceptions non encore gérées
        ...
../..
Exceptions
==========
`else` si aucune exception n'a été déclenchée

    `python
    try:
        x = 1
    except:
        print('erreur')
    else:
        print('ok')
../..
Exceptions
==========
`as` pour récupérer l'objet exception

    >>> x = [6]
    ... try:
    ...     x[2]
    ... except IndexError as exc:
    ...    print('erreur index',exc)
    ...
    ('erreur index', IndexError('list index out of range',))

L'objet `exc` est une _instance_ de la _classe_ `IndexError`
../..
Exceptions
==========
`raise` pour déclencher des exceptions

    >>> raise NameError('HiThere')
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    NameError: HiThere
    
Sans argument : re-déclenche la dernière exception gérée

    >>> try:
    ...     raise NameError('HiThere')
    ... except NameError:
    ...     print 'An exception flew by!'
    ...     raise
    ...
    An exception flew by!
    Traceback (most recent call last):
      File "<stdin>", line 2, in ?
    NameError: HiThere
    
../..
Exceptions
==========
`finally` pour exécuter un code qu'il y ait eu exception ou pas

Si une exception n'a pas été gérée, elle est déclenchée après `finally`

    >>> x = [5]
    >>> try:
    ...     print(x[2])
    ... finally:
    ...     print('Goodbye, world!')
    ...
    Goodbye, world!
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
    IndexError: list index out of range

../..
Exceptions
==========
    >>> def divide(x, y):
    ...     try:
    ...         result = x / y
    ...     except ZeroDivisionError:
    ...         print "division by zero!"
    ...     else:
    ...         print "result is", result
    ...     finally:
    ...         print "executing finally clause"
    ...
    >>> divide(2, 1)
    result is 2
    executing finally clause

    >>> divide(2, 0)
    division by zero!
    executing finally clause

    >>> divide("2", "1")
    executing finally clause
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
      File "<stdin>", line 3, in divide
    TypeError: unsupported operand type(s) for /: 'str' and 'str'
../..
Espaces de noms
===============
Permet de définir et d'utiliser le même nom dans des contextes différents

Variables globales / locales

    >>> a, b = 1, 2 # définit deux variables dans l'espace de noms global
    >>> def f():
    ...    global b # la variable b est globale
    ...    a = 3    # définit une variable a dans l'espace de noms 
    ...             # local de la fonction f
    ...    b = 99
    ...    print(a)
    ...
    >>> f()
    3
    >>> a
    1
    >>> b
    99
../..
Espaces de noms
===============

    x = 0

    def f(x):
        import Z

    import X
    
    from Y import A
    
    for i in range(5):
        j = 2 * i

définit les noms `x, f, X, A, i, j` dans l'espace de noms global ; `x, Z` dans l'espace de noms de f

NB : le nom `Y` n'est __pas__ dans l'espace de noms
../..
Espaces de noms
===============
A l'exécution, quand l'interpréteur rencontre un nom, il cherche dans l'espace de nom le plus proche, puis "remonte" jusqu'au niveau module puis aux noms intégrés de Python

    a = 6
    def f():
        b = 8
        def g(n):
            print(n)
            print(b)
            print(a)
        g(8)
 
Dans l'exécution de g : 
- pas de nom `print` dans les espaces locaux ni globaux, mais `print` est un mot clé de Python
- le nom `n` est dans l'espace de noms de g
- pas de nom `b` dans l'espace de noms de g, on remonte jusqu'à l'espace de noms de f
- pas de nom `a` dans l'espace de noms de g ni de f, on remonte jusqu'à l'espace de noms global
../..
Classes
=======
Définis par le mot clé `class`

    class ClassName:
        <statement-1>
        .
        .
        .
        <statement-N>

Le nom `ClassName` est ajouté dans l'espace de noms où la classe est définie

Une classe possède son propre espace de noms
../..
Classes
=======

    >>> class MyClass:
    ...    i = 12345
    ...
    >>> print(MyClass.i)

Les noms définis dans `MyClass` (_attributs_) sont accessibles depuis l'espace de noms "supérieur" par des _noms qualifiés_ (forme `klass.X`)

On peut modifier dynamiquement les attributs de la classe

    >>> MyClass.i = 23456    
../..
Classes
=======
Pour créer des instances d'une classe, on l'utilise comme une fonction :

    >>> class MyClass:
    ...    i = 12345
    ...
    >>> x = MyClass()

L'instance possède les mêmes attributs que la classe

    >>> x.i
    12345
../..
Classes
=======
Les _fonctions_ définies dans la classe deviennent les _méthodes_ des instances de cette classe

Par convention, on les écrit avec l'instance comme premier argument, appelé `self`

    >>> class MyClass:
    ...     def f(self):
    ...         print('function f')
    ...     def greet(self,name):
    ...         print('hello, ',name)
    ...
    >>> x = MyClass()
    >>> x.f()
    hello
    >>> x.greet('world')
    hello, world

`x.greet('world')` est équivalent à  `MyClass.greet(x,'world')`

../..
Classes
=======
Pour initialiser une instance avec des attributs spécifiques : fonction spéciale `__init__()`

    >>> class MyClass:
    ...     def __init__(self):
    ...         self.data = []
    ...
    >>> x = MyClass()
    >>> x.data
    []
../..
Classes
=======
On peut passer des arguments à la fonction `__init__`

    >>> class Complex:
    ...     def __init__(self, realpart, imagpart):
    ...         self.r = realpart
    ...         self.i = imagpart
    ...
    >>> x = Complex(3.0, -4.5)
    >>> x.r, x.i
    (3.0, -4.5)
../..
Classes
=======
Les méthodes peuvent appeler d'autres méthodes

    class Bag:

        def __init__(self):
            self.data = []

        def add(self, x):
            self.data.append(x)

        def addtwice(self, x):
            self.add(x)
            self.add(x)
../..
Héritage
========

    class DerivedClass(BaseClass):
        <statement-1>
        .
        .
        .
        <statement-N>

`DerivedClass` _hérite_, ou est _dérivée_, ou est une _sous-classe_ de `BaseClass`
../..
Héritage
========

    >>> class A:
    ...     x = 0
    ...
    >>> class B(A):
    ...     y = 1
    ...
    >>> obj = B()
    >>> obj.y
    1
    >>> obj.x
    0

La recherche (_résolution_) d'attribut est exécutée dans la classe B, puis dans la classe A dont B hérite
../..
Héritage
========
Une sous-classe peut réécrire (_surcharger_) les fonctions de la classe dont elle hérite

    class A:
        x = 0
        def show(self):
            print('je suis A')

    classe B(A):
        def show(self):
            print(je suis B')
../..
Héritage
========
On peut utiliser les fonctions de A dans les fonctions de B

    class A:
        def __init__(self, x):
            self.x = x**2

    class B(A):
        def __init__(self,x,y):
            A.__init__(self,x)
            self.y = y    
../..
Héritage
========
Exemple : les modules peuvent définir des _classes_ d'exception spécifiques, dérivées de la classe `Exception`

    >>> class MyError(Exception):
    ...     def __init__(self, value):
    ...         self.value = value
    ...
    >>> try:
    ...     raise MyError(4)
    ... except MyError as e:
    ...     print 'My exception occurred, value:', e.value
    ...
    My exception occurred, value: 4

`MyError(4)` crée une _instance_ de la classe `MyError` en passant l'argument `4`

La méthode `__init__(self, value)` initialise l'instance avec l'argument _value_
../..
Héritage
========
Héritage multiple

    class Derived(Base1, Base2, Base3):
        <statement-1>
        .
        .
        .
        <statement-N>
Construit pour la classe `Derived` un _ordre de résolution de méthodes_ (MRO) pour la résolution d'attributs ; exception en cas d'impossibilité
../..
Héritage
========
<code>issubclass(_A,B_)</code> teste si la classe _A_ hérite de la classe _B_

<code>isinstance(_obj,A_)</code> teste si l'objet _obj_ est une instance de _A_ ou d'une classe dont _A_ hérite

../..
Méthodes spéciales
==================

    >>> class A:
    ...     def __init__(self):
    ...         self.data = 'la cigale et la fourmi'
    ...     def __getitem__(self,i):
    ...         return self.data[i]
    ...
    >>> x = A()
    >>> x[3]
    c

La définition d'une méthode `__getitem__(self, pos)` permet d'utiliser l'accès par index
../..
Itérateurs
==========
Utilisés très fréquemment en Python

    for element in [1, 2, 3]:
        print element
    for element in (1, 2, 3):
        print element
    for key in {'one':1, 'two':2}:
        print key
    for char in "123":
        print char
    for line in open("myfile.txt"):
        print line
../..
Itérateurs
==========
Utilisent les fonctions intégrées 
- <code>iter(_instance_)</code> : retourne un itérateur sur l'_instance_
- <code>next(_iterateur_)</code> : retourne le prochain élément de l'itérateur, ou déclenche l'exception `StopIteration`

    >>> s = 'abc'
    >>> it = iter(s)
    >>> it
    <iterator object at 0x00A1DB50>
    >>> it.next()
    'a'
    >>> it.next()
    'b'
    >>> it.next()
    'c'
    >>> it.next()
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
        it.next()
    StopIteration
../..
Itérateurs
==========
`iterator = iter(instance)` équivaut à `iterator = instance.__iter__()`

`item = next(iterator)` équivaut à `item = iterator.next()`

Pour pouvoir itérer sur les instances d'une classe il faut lui définir une fonction `__iter__`, qui renvoie un objet qui possède une méthode `next`

    class Reverse:
        """Iterator for looping over a sequence backwards."""
        def __init__(self, data):
            self.data = data
            self.index = len(data)
        def __iter__(self):
            return self
        def next(self):
            if self.index == 0:
                raise StopIteration
            self.index = self.index - 1
            return self.data[self.index]
../..
Générateurs
===========
Création automatique d'itérateurs : fonctions qui utilisent `yield` au lieu de `return`

    >>> def squares(n):
    ...     """Itérateur sur les carrés des nombres de 0 à n"""
    ...     for i in range(n):
    ...         yield i*i
    ...
    >>> for x in squares(5):
    ...     print(x)
    ...
    0
    1
    4
    9
    16
../..
Generator expressions
=====================
Simplifie le passage d'argument à une fonction qui attend un itérateur

    >>> sum(i*i for i in range(10))                 # sum of squares
    285
    
    >>> xvec = [10, 20, 30]
    >>> yvec = [7, 5, 3]
    >>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
    260
    
    >>> unique_words = set(word  for line in page  for word in line.split())
../..
Décorateurs
===========
Fonction qui renvoie une autre fonction, utilisée avec `@`

    @staticmethod
    def f(...):
        ...

équivaut à

    def f(...):
        ...
    f = staticmethod(f)
    
../..
Librairie standard : `os`
==========================

    >>> import os
    >>> os.getcwd()      # renvoie le répertoire courant
    'C:\\Python26'
    >>> os.chdir('/server/accesslogs')   # Change le répertoire courant
    >>> os.mkdir('nouveau') # crée un nouveau répertoire
    >>> os.rmdir('nouveau') # supprime un répertoire

    >>> os.path.join('rep1','rep2','fichier.txt')
    'rep1\\rep2\\fichier.txt'
../..
Librairie standard : `shutil`
=============================
Utilitaires de manipulation de fichiers et de répertoires

    >>> import shutil
    >>> shutil.copyfile('data.db', 'archive.db') # recopie
    >>> shutil.move('/build/executables', 'installdir') # déplacement
../..
Librairie standard : `sys`
==========================
Arguments passés en ligne de commande (_python demo.py one two three_)

Dans _demo.py_

    import sys
    print(sys.argv) # liste des arguments passés après _python_
    ['demo.py', 'one', 'two', 'three']

Entrée et sortie standard : `sys.stdin, sys.stdout`

    sys.stdout.write('data')

Peut être modifié pour rediriger la sortie de `print`

    sys.stdout = file_obj # un objet avec une méthode write
    print('data')         # équivaut à file_obj.write('data\n')
../..
Librairie standard : `re` (expressions régulières)
==================================================
Fonctions avancées de recherche et remplacement de chaines de caractères

    >>> import re
    >>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
    ['foot', 'fell', 'fastest']
    >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
    'cat in the hat'
../..
Librairie standard : `math`
===========================
Fonctions mathématiques

    >>> import math
    >>> math.cos(math.pi / 4.0)
    0.70710678118654757
    >>> math.log(1024, 2)
    10.0
../..
Librairie standard : `random`
=============================
Fonctions aléatoires

    >>> import random
    >>> random.choice(['apple', 'pear', 'banana'])
    'apple'
    >>> random.sample(xrange(100), 10)   # sampling without replacement
    [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
    >>> random.random()    # random float
    0.17970987693706186
    >>> random.randrange(6)    # random integer chosen from range(6)
    4
../..
Librairie standard : `datetime`
===============================
Heures et dates
    
    >>> from datetime import date
    >>> now = date.today()
    >>> now
    datetime.date(2003, 12, 2)
    >>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
    '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'
    
    >>> # dates support calendar arithmetic
    >>> birthday = date(1964, 7, 31)
    >>> age = now - birthday
    >>> age.days
    14368
../..
Librairie standard : compression
================================
Modules standard `zlib, gzip, bz2, zipfile, tarfile`

    >>> import zlib
    >>> s = 'witch which has which witches wrist watch'
    >>> len(s)
    41
    >>> t = zlib.compress(s)
    >>> len(t)
    37
    >>> zlib.decompress(t)
    'witch which has which witches wrist watch'
    >>> zlib.crc32(s)
    226805979


